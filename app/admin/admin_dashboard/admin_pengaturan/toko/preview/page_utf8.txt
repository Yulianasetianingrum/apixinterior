import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

import Navbar from "@/app/navbar/page";
import homeStyles from "@/app/page.module.css";
import ui from "./preview.module.css";

import { CategoryGridPreview } from "./CategoryGridPreview";

export const dynamic = "force-dynamic";


const THEME_META_SLUG_PREFIX = "__theme_meta__";
const ADMIN_TOKO_PATH = "/admin/admin_dashboard/admin_pengaturan/toko";

type JsonObject = Record<string, any>;

type SectionRow = {
  id: number;
  type: string;
  title: string | null;
  slug: string | null;
  enabled: boolean;
  sortOrder: number;
  config: JsonObject;
};

type CategoryGridItem = { kategoriId: number; coverImageId: number | null };

function safeDecode(v: string) {
  if (!v) return "";
  try {
    return decodeURIComponent(v);
  } catch {
    return v;
  }
}

function readSp(sp: any, key: string): string {
  const raw = sp?.[key];
  if (typeof raw === "string") return safeDecode(raw);
  if (Array.isArray(raw)) return safeDecode(String(raw[0] ?? ""));
  return "";
}

function isObject(v: unknown): v is JsonObject {
  return !!v && typeof v === "object" && !Array.isArray(v);
}

function upperType(v: unknown) {
  return String(v ?? "").toUpperCase().trim();
}

function normalizeThemeKey(v: any): string {
  const s = String(v ?? "").trim();
  return s || "theme_1";
}

function normalizeThemeAttr(v: any): string {
  const s = String(v ?? "").trim();
  if (!s) return "";

  // Keep theme_1..theme_6 in lowercase because CSS selectors use that form.
  const m = s.match(/^theme[_-]?(\d+)$/i);
  if (m) return `theme_${Number(m[1])}`;

  // Normalize navbar combo tokens (NAVY_GOLD, etc), accept kebab-case input.
  // Normalize combos like "GOLD + NAVY" / "gold-navy" -> "GOLD_NAVY"
  return s.toUpperCase().replace(/[^A-Z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}


function categoryGridVarsFromTheme(resolvedTheme: string) {
  const NAVY = "#0b1d3a";
  const GOLD = "#d4af37";
  const WHITE = "#ffffff";

  // Defaults that are readable:
  // - Card BG = Background theme
  // - Inside-card text = Element theme
  // - Outside title text = Background theme, BUT if Background is WHITE -> use Element (so it's visible)
  switch (resolvedTheme) {
    case "NAVY_GOLD":
      return { cardBg: NAVY, insideText: GOLD, outsideText: NAVY, border: "rgba(255,255,255,0.22)" };
    case "WHITE_GOLD":
      return { cardBg: WHITE, insideText: GOLD, outsideText: GOLD, border: "rgba(11,29,58,0.18)" };
    case "NAVY_WHITE":
      return { cardBg: NAVY, insideText: WHITE, outsideText: NAVY, border: "rgba(255,255,255,0.22)" };
    case "GOLD_NAVY":
      return { cardBg: GOLD, insideText: NAVY, outsideText: GOLD, border: "rgba(11,29,58,0.20)" };
    case "GOLD_WHITE":
      return { cardBg: GOLD, insideText: WHITE, outsideText: GOLD, border: "rgba(255,255,255,0.22)" };
    case "WHITE_NAVY":
      return { cardBg: WHITE, insideText: NAVY, outsideText: NAVY, border: "rgba(11,29,58,0.18)" };
    default:
      return { cardBg: WHITE, insideText: NAVY, outsideText: NAVY, border: "rgba(11,29,58,0.18)" };
  }
}




function getThemeKeyFromConfig(cfg: any): string {
  if (cfg && typeof cfg === "object" && !Array.isArray(cfg) && typeof cfg.__themeKey === "string") {
    const v = String(cfg.__themeKey).trim();
    return v ? normalizeThemeKey(v) : "theme_1";
  }
  return "theme_1";
}

function isThemeMetaRow(row: any): boolean {
  const slug = String(row?.slug ?? "");
  const cfg = (row?.config ?? {}) as any;
  return slug.startsWith(THEME_META_SLUG_PREFIX) || cfg?.__isThemeMeta === true;
}

/**
 * Normalize per-section config so preview won't crash when config shape changes.
 * Keep this aligned with the CMS editor fields.
 */
function normalizeConfig(sectionType: string, raw: any): JsonObject {
  const cfg = isObject(raw) ? raw : {};

  if (sectionType === "HERO") {
    const headline = typeof (cfg as any).headline === "string" ? (cfg as any).headline : "";
    const subheadline = typeof (cfg as any).subheadline === "string" ? (cfg as any).subheadline : "";
    const ctaLabel = typeof (cfg as any).ctaLabel === "string" ? (cfg as any).ctaLabel : "";
    const ctaHref = typeof (cfg as any).ctaHref === "string" ? (cfg as any).ctaHref : "";
    const eyebrow = typeof (cfg as any).eyebrow === "string" ? (cfg as any).eyebrow : "";

    const badges = Array.isArray((cfg as any).badges)
      ? (cfg as any).badges.map((v: any) => String(v ?? "").trim()).filter(Boolean).slice(0, 8)
      : [];

    const highlights = Array.isArray((cfg as any).highlights)
      ? (cfg as any).highlights.map((v: any) => String(v ?? "").trim()).filter(Boolean).slice(0, 8)
      : [];

    const trustChips = Array.isArray((cfg as any).trustChips)
      ? (cfg as any).trustChips.map((v: any) => String(v ?? "").trim()).filter(Boolean).slice(0, 8)
      : [];

    const heroTheme = typeof (cfg as any).heroTheme === "string" ? (cfg as any).heroTheme : "FOLLOW_NAVBAR";

    const imageIdNum = Number((cfg as any).imageId);
    const imageId = Number.isFinite(imageIdNum) && imageIdNum > 0 ? imageIdNum : null;

    return {
      headline,
      subheadline,
      ctaLabel,
      ctaHref,
      ...(eyebrow ? { eyebrow } : {}),
      ...(badges.length ? { badges } : {}),
      ...(highlights.length ? { highlights } : {}),
      ...(trustChips.length ? { trustChips } : {}),
      heroTheme,
      imageId,
      __themeKey: getThemeKeyFromConfig(cfg),
    };
  }

  if (sectionType === "CATEGORY_GRID") {
    const itemsNew: CategoryGridItem[] = Array.isArray((cfg as any).items)
      ? (cfg as any).items
          .map((it: any) => ({
            kategoriId: Number(it?.kategoriId),
            coverImageId:
              it?.coverImageId === null || it?.coverImageId === undefined || it?.coverImageId === ""
                ? null
                : Number(it.coverImageId),
          }))
          .filter((it: any) => Number.isFinite(it.kategoriId))
      : [];

    const layoutObj = isObject((cfg as any).layout) ? (cfg as any).layout : {};
    const columnsRaw = Number((layoutObj as any).columns ?? 3);
    const columns = Math.min(6, Math.max(2, Number.isNaN(columnsRaw) ? 3 : columnsRaw));

    const maxItems =
      (layoutObj as any).maxItems === undefined || (layoutObj as any).maxItems === null
        ? undefined
        : Math.max(1, Number((layoutObj as any).maxItems));

    const sectionThemeRaw =
      typeof (cfg as any).sectionTheme === "string"
        ? String((cfg as any).sectionTheme).trim()
        : typeof (cfg as any).gridTheme === "string"
          ? String((cfg as any).gridTheme).trim()
          : typeof (cfg as any).categoryGridTheme === "string"
            ? String((cfg as any).categoryGridTheme).trim()
            : typeof (cfg as any).categoryTheme === "string"
              ? String((cfg as any).categoryTheme).trim()
              : typeof (cfg as any).theme === "string"
                ? String((cfg as any).theme).trim()
                : typeof (cfg as any).colorTheme === "string"
                  ? String((cfg as any).colorTheme).trim()
                  : typeof (cfg as any).temaWarna === "string"
                    ? String((cfg as any).temaWarna).trim()
                    : typeof (cfg as any).warnaTema === "string"
                      ? String((cfg as any).warnaTema).trim()
                      : typeof (cfg as any).temaWarnaSection === "string"
                        ? String((cfg as any).temaWarnaSection).trim()
                        : typeof (cfg as any).heroTheme === "string"
                          ? String((cfg as any).heroTheme).trim()
                          : "";

    // Empty string means "default look" (cards stay white like current).
    // If CMS stores FOLLOW_NAVBAR explicitly, we'll resolve it in the renderer.
    const sectionTheme = sectionThemeRaw;

    const titleTextColorRaw =
      typeof (cfg as any).titleTextColor === "string" ? String((cfg as any).titleTextColor).trim() : "";
    const titleTextColor =
      titleTextColorRaw === "NAVY" || titleTextColorRaw === "GOLD" || titleTextColorRaw === "WHITE"
        ? titleTextColorRaw
        : null;


    return {
      items: itemsNew,
      layout: { columns, ...(maxItems ? { maxItems } : {}) },
      __themeKey: getThemeKeyFromConfig(cfg),
      sectionTheme,
      titleTextColor,
    };
  }

  if (sectionType === "PRODUCT_CAROUSEL") {
    const description = typeof (cfg as any).description === "string" ? (cfg as any).description : "";

const showPrice = (cfg as any).showPrice === undefined ? true : Boolean((cfg as any).showPrice);
    const showCta = (cfg as any).showCta === undefined ? true : Boolean((cfg as any).showCta);

    const productIds = Array.isArray((cfg as any).productIds)
      ? (cfg as any).productIds.map((v: any) => Number(v)).filter((n: any) => Number.isFinite(n))
      : [];

    return {
      description,
      showPrice,
      showCta,
      productIds,
      __themeKey: getThemeKeyFromConfig(cfg),
    };
  }

  if (sectionType === "HIGHLIGHT_COLLECTION") {
    const headline =
      typeof (cfg as any).headline === "string"
        ? String((cfg as any).headline)
        : typeof (cfg as any).title === "string"
          ? String((cfg as any).title)
          : "";
    const description =
      typeof (cfg as any).description === "string"
        ? String((cfg as any).description)
        : typeof (cfg as any).subtitle === "string"
          ? String((cfg as any).subtitle)
          : "";

    const layoutRaw = String((cfg as any).layout ?? "FEATURED_LEFT");
    const layout =
      layoutRaw === "FEATURED_LEFT" || layoutRaw === "FEATURED_TOP" || layoutRaw === "GRID" || layoutRaw === "CARDS"
        ? layoutRaw
        : "FEATURED_LEFT";

    const ctaText = typeof (cfg as any).ctaText === "string" ? String((cfg as any).ctaText) : "";
    const ctaHref = typeof (cfg as any).ctaHref === "string" ? String((cfg as any).ctaHref) : "";

    const heroImageIdNum = Number((cfg as any).heroImageId);
    const heroImageId = Number.isFinite(heroImageIdNum) && heroImageIdNum > 0 ? heroImageIdNum : null;

    const productIds = Array.isArray((cfg as any).productIds)
      ? (cfg as any).productIds.map((v: any) => Number(v)).filter((n: any) => Number.isFinite(n))
      : [];

    const allowedThemes = new Set([
      "NAVY_GOLD",
      "WHITE_GOLD",
      "NAVY_WHITE",
      "GOLD_NAVY",
      "GOLD_WHITE",
      "WHITE_NAVY",
      "theme_1",
      "theme_2",
      "theme_3",
      "theme_4",
      "theme_5",
      "theme_6",
    ]);
    const sectionThemeRaw =
      typeof (cfg as any).sectionTheme === "string" ? String((cfg as any).sectionTheme).trim() : "FOLLOW_NAVBAR";
    const sectionTheme =
      sectionThemeRaw === "FOLLOW_NAVBAR"
        ? "FOLLOW_NAVBAR"
        : allowedThemes.has(sectionThemeRaw)
          ? sectionThemeRaw
          : "FOLLOW_NAVBAR";

    return {
      headline: headline.trim(),
      description: description.trim(),
      badgeText: "",
      layout,
      heroImageId,
      productIds,
      ctaText: ctaText.trim(),
      ctaHref: ctaHref.trim(),
      sectionTheme,
      __themeKey: getThemeKeyFromConfig(cfg),
    };
  }

  if (sectionType === "ROOM_CATEGORY") {
    const cardsRaw = Array.isArray((cfg as any).cards) ? (cfg as any).cards : [];
    const cards = cardsRaw
      .map((c: any, idx: number) => {
        const key = String(c?.key ?? "").trim() || `card_${idx + 1}`;
        const title = typeof c?.title === "string" ? c.title : "";
        const description = typeof c?.description === "string" ? c.description : "";

        const kategoriIdNum = Number(c?.kategoriId);
        const kategoriId = Number.isFinite(kategoriIdNum) && kategoriIdNum > 0 ? kategoriIdNum : null;

        const imageIdNum = Number(c?.imageId);
        const imageId = Number.isFinite(imageIdNum) && imageIdNum > 0 ? imageIdNum : null;

        const badgeRaw = c?.badge;
const badge =
  typeof badgeRaw === "string" && badgeRaw.trim().length > 0 ? badgeRaw.trim() : null;

const cropYNum = Number(c?.cropY);
        const cropY = Number.isFinite(cropYNum) ? Math.max(0, Math.min(100, cropYNum)) : 50;

        const zoomNum = Number(c?.zoom);
        const zoom = Number.isFinite(zoomNum) ? Math.max(1, Math.min(3, zoomNum)) : 1;

        const mediaHeightNum = Number(c?.mediaHeight);
        const mediaHeight =
          Number.isFinite(mediaHeightNum) && mediaHeightNum > 0 ? Math.max(80, Math.min(520, mediaHeightNum)) : null;

        return { key, title, description, badge, kategoriId, imageId, cropY, zoom, mediaHeight };
      })
      .slice(0, 30);

    return { ...(cfg as any), cards, __themeKey: getThemeKeyFromConfig(cfg) };
  }

  return { ...(cfg as any), __themeKey: getThemeKeyFromConfig(cfg) };
}

/**
 * Pick first gallery image id (robust):
 * - number: return it
 * - json array string: use first element
 * - string "1,2,3" or "1": take first number occurrence
 */
function pickFirstGalleryImageId(raw: any): number | null {
  if (!raw) return null;
  if (typeof raw === "number") return Number.isFinite(raw) && raw > 0 ? raw : null;

  const s = String(raw).trim();
  if (!s) return null;

  try {
    const parsed = JSON.parse(s);
    if (Array.isArray(parsed) && parsed.length) {
      const n = Number(parsed[0]);
      return Number.isFinite(n) && n > 0 ? n : null;
    }
  } catch {
    // ignore
  }

  const m = s.match(/\d+/);
  if (!m) return null;
  const n = Number(m[0]);
  return Number.isFinite(n) && n > 0 ? n : null;
}

async function publishTheme(formData: FormData) {
  "use server";

  const themeKey = normalizeThemeKey(String(formData.get("themeKey") ?? "").trim());

  const meta = await prisma.homepageSectionDraft.findFirst({
    where: { slug: `${THEME_META_SLUG_PREFIX}${themeKey}` },
    select: { id: true },
  });

  if (!meta) {
    redirect(
      `${ADMIN_TOKO_PATH}/preview?theme=${encodeURIComponent(themeKey)}&error=${encodeURIComponent(
        "Belum ada theme ini. Buat theme dulu sebelum publish.",
      )}`,
    );
  }

  const allDrafts = await prisma.homepageSectionDraft.findMany({
    orderBy: [{ sortOrder: "asc" }, { id: "asc" }],
  });

  // Theme meta (e.g. backgroundTheme) for this themeKey
  const themeMetaRow = (allDrafts as any[]).find(
    (d) => String(d?.slug ?? "") === `${THEME_META_SLUG_PREFIX}${themeKey}`,
  );
  const themeMetaCfg = isObject((themeMetaRow as any)?.config) ? ((themeMetaRow as any).config as any) : {};
  const backgroundTheme =
    typeof themeMetaCfg?.backgroundTheme === "string" ? String(themeMetaCfg.backgroundTheme).trim() : "FOLLOW_NAVBAR";
  const themeName =
    typeof themeMetaCfg?.themeName === "string" ? String(themeMetaCfg.themeName).trim() : "";



  const drafts = (allDrafts as any[])
    .filter((d) => !isThemeMetaRow(d))
    .filter((d) => getThemeKeyFromConfig(d?.config) === themeKey);

  await prisma.$transaction([
    prisma.homepageSectionPublished.deleteMany({}),
    ...drafts.map((d) =>
      prisma.homepageSectionPublished.create({
        data: {
          type: d.type as any,
          title: d.title,
          slug: d.slug,
          enabled: d.enabled,
          sortOrder: d.sortOrder,
          config: d.config,
        },
      }),
    ),
  ]);

  revalidatePath("/");
  revalidatePath(ADMIN_TOKO_PATH);

  redirect(
    `${ADMIN_TOKO_PATH}/preview?theme=${encodeURIComponent(themeKey)}&notice=${encodeURIComponent(
      "Publish berhasil. Homepage utama sudah di-refresh.",
    )}`,
  );
}

async function fetchPreviewTheme(themeKey: string) {
  const allDrafts = await prisma.homepageSectionDraft.findMany({
    orderBy: [{ sortOrder: "asc" }, { id: "asc" }],
  });

  const draftSections: SectionRow[] = (allDrafts as any[])
    .filter((d) => !isThemeMetaRow(d))
    .filter((d) => getThemeKeyFromConfig(d?.config) === themeKey)
    .filter((d) => d.enabled === true)
    .map((d) => ({
      id: Number(d.id),
      type: String(d.type),
      title: d.title ?? null,
      slug: d.slug ?? null,
      enabled: Boolean(d.enabled),
      sortOrder: Number(d.sortOrder ?? 0),
      config: normalizeConfig(String(d.type), d.config),
    }));

  // ===== Collect IDs to prefetch related data =====
  const kategoriIds: number[] = [];
  const autoCoverKategoriIds: number[] = [];
  const imageIds: number[] = [];
  const produkIds: number[] = [];
  const highlightProdukIds: number[] = [];

  const categoryGridById = new Map<number, { items: CategoryGridItem[]; columns: number; maxItems?: number }>();

  for (const s of draftSections) {
    if (s.type === "CATEGORY_GRID") {
      const cfg = s.config as any;
      const items: CategoryGridItem[] = Array.isArray(cfg.items) ? cfg.items : [];
      const layout = isObject(cfg.layout) ? cfg.layout : {};
      const columns = Number.isFinite(Number(layout.columns)) ? Math.max(2, Math.min(6, Number(layout.columns))) : 3;
      const maxItems = layout.maxItems ? Number(layout.maxItems) : undefined;

      for (const it of items) {
        if (it?.kategoriId) {
          kategoriIds.push(Number(it.kategoriId));
          if (it.coverImageId && Number.isFinite(it.coverImageId)) {
            imageIds.push(Number(it.coverImageId));
          } else {
            autoCoverKategoriIds.push(Number(it.kategoriId));
          }
        }
      }

      categoryGridById.set(s.id, { items, columns, ...(maxItems ? { maxItems } : {}) });
    }

    if (s.type === "HERO") {
      const imgId = Number((s.config as any).imageId);
      if (Number.isFinite(imgId) && imgId > 0) imageIds.push(imgId);
    }

    if (s.type === "PRODUCT_CAROUSEL") {
      const ids = Array.isArray((s.config as any).productIds) ? (s.config as any).productIds : [];
      for (const id of ids) {
        const n = Number(id);
        if (Number.isFinite(n) && n > 0) produkIds.push(n);
      }
    }

    if (s.type === "HIGHLIGHT_COLLECTION") {
      const heroImageId = Number((s.config as any).heroImageId);
      if (Number.isFinite(heroImageId) && heroImageId > 0) imageIds.push(heroImageId);

      const ids = Array.isArray((s.config as any).productIds) ? (s.config as any).productIds : [];
      for (const id of ids) {
        const n = Number(id);
        if (Number.isFinite(n) && n > 0) {
          highlightProdukIds.push(n);
          produkIds.push(n);
        }
      }
    }
    if (s.type === "ROOM_CATEGORY") {
      const cfg = s.config as any;
      const cards = Array.isArray(cfg.cards) ? cfg.cards : [];
      for (const c of cards) {
        const kId = Number(c?.kategoriId);
        if (Number.isFinite(kId) && kId > 0) kategoriIds.push(kId);

        const imgId = Number(c?.imageId);
        if (Number.isFinite(imgId) && imgId > 0) {
          imageIds.push(imgId);
        } else if (Number.isFinite(kId) && kId > 0) {
          // allow auto cover (fallback) when room card has kategoriId but no image
          autoCoverKategoriIds.push(kId);
        }
      }
    }

  }

  const uniqKategoriIds = Array.from(new Set(kategoriIds)).filter((n) => Number.isFinite(n));
  const uniqAutoCoverKategoriIds = Array.from(new Set(autoCoverKategoriIds)).filter((n) => Number.isFinite(n));
  const uniqImageIds = Array.from(new Set(imageIds)).filter((n) => Number.isFinite(n));
  const uniqProdukIds = Array.from(new Set(produkIds)).filter((n) => Number.isFinite(n));
  const uniqHighlightProdukIds = Array.from(new Set(highlightProdukIds)).filter((n) => Number.isFinite(n));

  // ===== Prefetch categories =====
  const kategoriMap = new Map<number, any>();
  if (uniqKategoriIds.length) {
    const kategoris = await prisma.kategoriProduk.findMany({
      where: { id: { in: uniqKategoriIds } },
      select: { id: true, nama: true, slug: true },
    });
    for (const k of kategoris as any[]) kategoriMap.set(Number(k.id), k);
  }

  // ===== Prefetch products =====
  const produkById = new Map<number, any>();
  if (uniqProdukIds.length) {
    const produk = await prisma.produk.findMany({
      where: { id: { in: uniqProdukIds } },
      select: {
        id: true,
        nama: true,
        slug: true,
        harga: true,
                promoAktif: true,
        promoTipe: true,
        promoValue: true,
kategori: true,
        subkategori: true,
        mainImageId: true,
        galleryImageIds: true,
      },
    });

    for (const p of produk as any[]) {
      produkById.set(Number(p.id), p);
      const mainId = p.mainImageId ? Number(p.mainImageId) : null;
      if (mainId) uniqImageIds.push(mainId);

      const gId = pickFirstGalleryImageId(p.galleryImageIds);
      if (gId) uniqImageIds.push(gId);
    }
  }

  // ===== Auto cover for categories (use first product in kategori_produk_item order) =====
  const autoCoverImageIdByKategori = new Map<number, number>();
  if (uniqAutoCoverKategoriIds.length) {
    const items = await prisma.kategoriProdukItem.findMany({
      where: { kategoriId: { in: uniqAutoCoverKategoriIds } },
      orderBy: [{ kategoriId: "asc" }, { urutan: "asc" }, { id: "asc" }],
      select: { kategoriId: true, produkId: true },
    });

    const firstProdukIdByKategori = new Map<number, number>();
    for (const it of items as any[]) {
      const kId = Number(it.kategoriId);
      if (!firstProdukIdByKategori.has(kId) && it.produkId) {
        firstProdukIdByKategori.set(kId, Number(it.produkId));
      }
    }

    const produkIdsAuto = Array.from(new Set(Array.from(firstProdukIdByKategori.values()))).filter((n) => n > 0);

    if (produkIdsAuto.length) {
      const produkAuto = await prisma.produk.findMany({
        where: { id: { in: produkIdsAuto } },
        select: { id: true, mainImageId: true, galleryImageIds: true },
      });

      const produkAutoById = new Map<number, any>();
      for (const p of produkAuto as any[]) produkAutoById.set(Number(p.id), p);

      for (const [kategoriId, produkId] of firstProdukIdByKategori.entries()) {
        const p = produkAutoById.get(Number(produkId));
        const mainId = p?.mainImageId ? Number(p.mainImageId) : null;
        const galleryId = pickFirstGalleryImageId(p?.galleryImageIds);

        const chosen = mainId || galleryId;
        if (chosen) {
          autoCoverImageIdByKategori.set(Number(kategoriId), Number(chosen));
          uniqImageIds.push(Number(chosen));
        }
      }
    }
  }

  // ===== Prefetch images =====
  const imageMap = new Map<number, any>();
  if (uniqImageIds.length) {
    const imgs = await prisma.gambarUpload.findMany({
      where: { id: { in: Array.from(new Set(uniqImageIds)) } },
      select: { id: true, url: true },
    });
    for (const img of imgs as any[]) imageMap.set(Number(img.id), img);
  }

  // Auto cover URL by kategori
  const autoCoverUrlByKategori = new Map<number, string>();
  for (const [kategoriId, imgId] of autoCoverImageIdByKategori.entries()) {
    const url = imageMap.get(Number(imgId))?.url;
    if (url) autoCoverUrlByKategori.set(Number(kategoriId), String(url));
  }

  // Theme meta (e.g. backgroundTheme) for this themeKey
  const themeMetaRow = (allDrafts as any[]).find(
    (d) => String(d?.slug ?? "") === `${THEME_META_SLUG_PREFIX}${themeKey}`,
  );
  const themeMetaCfg = isObject((themeMetaRow as any)?.config) ? ((themeMetaRow as any).config as any) : {};
  const backgroundTheme =
    typeof themeMetaCfg?.backgroundTheme === "string" ? String(themeMetaCfg.backgroundTheme).trim() : "FOLLOW_NAVBAR";


  
  const themeName =
    typeof themeMetaCfg?.themeName === "string" ? String(themeMetaCfg.themeName).trim() : "";

return { draftSections, categoryGridById, kategoriMap, imageMap, autoCoverUrlByKategori, produkMap: produkById, backgroundTheme, themeName };
}

type CategoryGridPreviewItemUI = {
  categoryId: number;
  title: string;
  href: string;
  imageUrl?: string | null;
  subtitle?: string | null;
};

function buildCategoryGridProps(args: {
  sectionTitle?: string | null;
  columns: number;
  maxItems?: number;
  items: CategoryGridItem[];
  kategoriMap: Map<number, any>;
  imageMap: Map<number, any>;
  autoCoverUrlByKategori: Map<number, string>;
}) {
  const cols = Math.min(6, Math.max(2, Number(args.columns || 3)));
  const maxItems = args.maxItems ? Math.max(1, Number(args.maxItems)) : undefined;

  const uiItems: CategoryGridPreviewItemUI[] = args.items.map((it) => {
    const k = args.kategoriMap.get(Number(it.kategoriId));
    const title = String(k?.nama ?? "Kategori");
    const href = k?.slug ? `/kategori/${k.slug}` : "#";

    const coverUrl =
      it.coverImageId && Number.isFinite(it.coverImageId)
        ? args.imageMap.get(Number(it.coverImageId))?.url ?? null
        : args.autoCoverUrlByKategori.get(Number(it.kategoriId)) ?? null;

    return {
      categoryId: Number(it.kategoriId),
      title,
      href,
      imageUrl: coverUrl,
      subtitle: null,
    } satisfies CategoryGridPreviewItemUI;
  });

  const finalItems = maxItems ? uiItems.slice(0, maxItems) : uiItems;

  return {
    title: args.sectionTitle ?? "Grid Kategori Produk",
    columns: cols,
    items: finalItems,
  };
}

function heroThemeClassFromConfig(heroThemeRaw: string, navbarThemeRaw: string) {
  const heroTheme = normalizeThemeAttr(heroThemeRaw || "FOLLOW_NAVBAR");
  const navbarTheme = normalizeThemeAttr(navbarThemeRaw || "NAVY_GOLD") || "NAVY_GOLD";

  const resolved = heroTheme === "FOLLOW_NAVBAR" || !heroTheme ? navbarTheme : heroTheme;

  switch (resolved) {
    case "WHITE_GOLD":
      return ui.heroThemeWhiteGold;
    case "NAVY_WHITE":
      return ui.heroThemeNavyWhite;
    case "WHITE_NAVY":
      return ui.heroThemeWhiteNavy;
    case "GOLD_NAVY":
      return ui.heroThemeGoldNavy;
    case "GOLD_WHITE":
      return ui.heroThemeGoldWhite;
    case "NAVY_GOLD":
    default:
      return ui.heroThemeNavyGold;
  }
}

function formatRupiah(n: any) {
  if (typeof n !== "number") return "";
  return new Intl.NumberFormat("id-ID", { style: "currency", currency: "IDR", maximumFractionDigits: 0 }).format(n);
}

function computeHargaSetelahPromo(p: any) {
  const hargaAsli = Math.round(Number(p?.harga ?? 0) || 0);
  const aktif = !!p?.promoAktif;
  const tipe = (p?.promoTipe ?? null) as "persen" | "nominal" | null;
  const valueRaw = Math.round(Number(p?.promoValue ?? 0) || 0);

  if (!aktif || !tipe || valueRaw <= 0 || hargaAsli <= 0) {
    return { hargaAsli, hargaFinal: hargaAsli, isPromo: false, promoLabel: "" };
  }

  let diskon = 0;
  if (tipe === "persen") {
    const pct = Math.max(0, Math.min(100, valueRaw));
    diskon = Math.round((pct / 100) * hargaAsli);
  } else {
    diskon = Math.max(0, Math.min(hargaAsli, valueRaw));
  }

  const hargaFinal = Math.max(0, hargaAsli - diskon);

  if (diskon <= 0 || hargaFinal >= hargaAsli) {
    return { hargaAsli, hargaFinal: hargaAsli, isPromo: false, promoLabel: "" };
  }

  const promoLabel =
    tipe === "persen"
      ? `-${Math.max(0, Math.min(100, valueRaw))}%`
      : `-Rp ${diskon.toLocaleString("id-ID")}`;

  return { hargaAsli, hargaFinal, isPromo: true, promoLabel };
}


export default async function TokoPreviewDraftPage({
  searchParams,
}: {
  searchParams?: Record<string, string | string[] | undefined> | Promise<Record<string, any>>;
}) {
  const spAny: any = searchParams as any;
  const sp = spAny && typeof spAny.then === "function" ? await spAny : spAny;

  const themeKey = normalizeThemeKey(readSp(sp, "theme") || "theme_1");
  const focus = upperType(readSp(sp, "focus"));
  const notice = readSp(sp, "notice").trim();
  const error = readSp(sp, "error").trim();

  // Navbar theme is the source-of-truth for FOLLOW_NAVBAR behavior in preview.
  const navbarSetting = await prisma.navbarSetting.findFirst({ select: { theme: true } });
  const navbarTheme = normalizeThemeAttr((navbarSetting as any)?.theme || "NAVY_GOLD") || "NAVY_GOLD";

  const { draftSections, categoryGridById, kategoriMap, imageMap, autoCoverUrlByKategori, produkMap, backgroundTheme, themeName } =
    await fetchPreviewTheme(themeKey);

  const displayThemeName = themeName || themeKey;

  const bgThemeAttr = normalizeThemeAttr(backgroundTheme || "FOLLOW_NAVBAR");
  const pageThemeAttr = bgThemeAttr === "FOLLOW_NAVBAR" || !bgThemeAttr ? navbarTheme : bgThemeAttr;

  return (
    <>
      <Navbar />

      <div className={ui.floatingBar}>
        <a className={ui.floatingLink} href={`${ADMIN_TOKO_PATH}?theme=${encodeURIComponent(themeKey)}`}>
          ? Kembali ke /toko
        </a>

        <span style={{ color: "rgba(255,255,255,0.85)", fontWeight: 900 }}>
          Preview Draft Theme: <span style={{ color: "white" }}>{displayThemeName}</span>
        </span>

        <form action={publishTheme} style={{ display: "inline-flex", gap: 10, marginLeft: "auto" }}>
          <input type="hidden" name="themeKey" value={themeKey} />
          <button type="submit" className={ui.publishBtn}>
            Publish ke Website Utama
          </button>
        </form>
      </div>

      <main className={`${homeStyles.homepageMain} ${ui.pageBg}`} data-theme={pageThemeAttr}>
        <div className={ui.noticeWrap}>
          {notice ? (
            <div className={ui.notice}>
              <strong>Info:</strong> {notice}
            </div>
          ) : null}

          {error ? (
            <div className={ui.error}>
              <strong>Error:</strong> {error}
            </div>
          ) : null}
        </div>

        {draftSections.length ? (
          <>
            {draftSections.map((section) => {
              const t = upperType(section.type);
              if (focus && t !== focus) return null;

              // CATEGORY GRID
              if (t === "CATEGORY_GRID") {
                const data = categoryGridById.get(section.id);
                if (!data) return null;

                const categoryGridData = buildCategoryGridProps({
                  sectionTitle: section.title,
                  columns: data.columns,
                  maxItems: data.maxItems,
                  items: data.items,
                  kategoriMap,
                  imageMap,
                  autoCoverUrlByKategori,
                });

                const gridThemeRaw = String(((section.config as any)?.sectionTheme ?? "")).trim();
                const titleTextColorRaw = String(((section.config as any)?.titleTextColor ?? "")).trim();
                const titleTextColor =
                  titleTextColorRaw === "NAVY"
                    ? "#0b1d3a"
                    : titleTextColorRaw === "GOLD"
                      ? "#d4af37"
                      : titleTextColorRaw === "WHITE"
                        ? "#ffffff"
                        : null;


                // Default (admin doesn't pick / FOLLOW_NAVBAR): keep current white cards
                if (!gridThemeRaw || gridThemeRaw === "FOLLOW_NAVBAR" || gridThemeRaw === "DEFAULT") {
                  if (!titleTextColor) {
                    return <CategoryGridPreview key={section.id} data={categoryGridData} />;
                  }

                  return (
                    <div key={section.id} style={{ ["--cg-title-color" as any]: titleTextColor }}>
                      <CategoryGridPreview data={categoryGridData} />
                    </div>
                  );
                }

                const gridResolvedTheme = normalizeThemeAttr(gridThemeRaw);

                const vars = categoryGridVarsFromTheme(gridResolvedTheme);

                return (
                  <div
                    key={section.id}
                    // Inline CSS variables so CATEGORY_GRID theme works even if other CSS modules hardcode colors.
                    style={{
                      ["--cg-card-bg" as any]: vars.cardBg,
                      ["--cg-card-fg" as any]: vars.insideText,
                      ["--cg-element" as any]: vars.outsideText,
                      ["--cg-title-color" as any]: titleTextColor ?? vars.outsideText,
                      ["--cg-card-border" as any]: vars.border,
                    }}
                  >
                    <CategoryGridPreview data={categoryGridData} />
                  </div>
                );
              }

              // HERO
              if (t === "HERO") {
                const cfg = normalizeConfig(t, section.config) as any;

                const eyebrow = String(cfg.eyebrow ?? "").trim() || "Interior Essentials";
                const headline = String(cfg.headline ?? "").trim() || "Kurasi Furnitur & Dekor untuk Rumahmu";
                const subheadline =
                  String(cfg.subheadline ?? "").trim() ||
                  "Belanja koleksi interior pilihan — style minimal, material premium, dan ready untuk berbagai ruang.";

                const ctaLabel = String(cfg.ctaLabel ?? "").trim();
                const ctaHref = String(cfg.ctaHref ?? "").trim();

                // No extra buttons: we render ONLY CTA from CMS.
                const badges: string[] = Array.isArray(cfg.badges) ? cfg.badges : [];
                const highlights: string[] = Array.isArray(cfg.highlights) ? cfg.highlights : [];
                const trustChips: string[] = Array.isArray(cfg.trustChips) ? cfg.trustChips : [];

                const finalBadges =
                  badges.length > 0 ? badges.slice(0, 4) : ["Ready Stock", "Kurasi Interior", "Material Premium"];

                const finalHighlights =
                  highlights.length > 0
                    ? highlights.slice(0, 3)
                    : ["Gratis konsultasi styling", "Pilihan warna netral hangat", "Cocok untuk ruang kecil"];

                const finalTrust = trustChips.length > 0 ? trustChips.slice(0, 6) : ["Pembayaran Aman", "Garansi", "Support CS"];

                const heroThemeClass = heroThemeClassFromConfig(String(cfg.heroTheme ?? "FOLLOW_NAVBAR"), navbarTheme);

                const imageId = Number(cfg.imageId);
                const imgUrl = Number.isFinite(imageId) && imageId > 0 ? imageMap.get(imageId)?.url ?? null : null;

                // Mini “commerce” stats (preview-only)
                const mini = [
                  { title: "? 4.8", desc: "Rating pelanggan" },
                  { title: "1.2k+", desc: "Produk tersedia" },
                  { title: "Fast", desc: "Respon CS" },
                ];

                return (
                  <section key={section.id} className={`${homeStyles.hero} ${ui.hero} ${ui.heroV1} ${heroThemeClass}`}>
                    <div className={ui.heroInner}>
                      <div className={ui.heroText}>
                        <div className={ui.heroTopRow}>
                          <div className={ui.heroEyebrow}>{eyebrow}</div>

                          <div className={ui.heroTopBadges}>
                            {finalBadges.map((b, idx) => (
                              <span key={idx} className={ui.heroBadge}>
                                {b}
                              </span>
                            ))}
                          </div>
                        </div>

                        <h1 className={ui.heroTitle}>{headline}</h1>
                        <p className={ui.heroDescription}>{subheadline}</p>

                        {ctaLabel ? (
                          <div className={ui.heroActions}>
                            <a className={`${ui.heroCta} ${ui.heroCtaPrimary}`} href={ctaHref || "#"}>
                              {ctaLabel}
                            </a>
                          </div>
                        ) : null}

                        <ul className={ui.heroHighlights}>
                          {finalHighlights.map((text, idx) => (
                            <li key={idx} className={ui.heroHighlightItem}>
                              <span className={ui.heroHighlightIcon}>?</span>
                              <span className={ui.heroHighlightText}>{text}</span>
                            </li>
                          ))}
                        </ul>

                        <div className={ui.heroTrustRow}>
                          {finalTrust.map((text, idx) => (
                            <span key={idx} className={ui.heroTrustChip}>
                              {text}
                            </span>
                          ))}
                        </div>

                        <div className={ui.heroMiniInfoRow}>
                          {mini.map((m, idx) => (
                            <div key={idx} className={ui.heroMiniInfoCard}>
                              <div className={ui.heroMiniInfoTitle}>{m.title}</div>
                              <div className={ui.heroMiniInfoDesc}>{m.desc}</div>
                            </div>
                          ))}
                        </div>
                      </div>

                      <div className={ui.heroMedia}>
                        <div className={ui.heroMediaBg} aria-hidden="true" />
                        {imgUrl ? (
                          <img className={ui.heroImage} src={imgUrl} alt={headline} />
                        ) : (
                          <div className={ui.heroMediaPlaceholder} aria-hidden="true" />
                        )}

                        {/* Decorative floating cards (no extra CTA button) */}
                        <div className={ui.heroFloatingCards} aria-hidden="true">
                          <div className={`${ui.heroFloatCard} ${ui.heroFloatCardRight}`}>
                            <div className={ui.heroFloatLabel}>Lookbook Minggu Ini</div>
                            <div className={ui.heroFloatMeta}>
                              <span className={ui.heroFloatDot} /> Inspirasi ruang & koleksi pilihan
                            </div>
                          </div>

                          <div className={`${ui.heroFloatCard} ${ui.heroFloatCardWide}`}>
                            <div className={ui.heroFloatLabel}>Promo</div>
                            <div className={ui.heroFloatRow}>
                              <span className={ui.heroFloatDot} />
                              <span className={ui.heroFloatRowText}>Gratis ongkir* untuk area tertentu</span>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </section>
                );
              }

              // PRODUCT CAROUSEL
              if (t === "PRODUCT_CAROUSEL") {
                const cfg = normalizeConfig(t, section.config) as any;
                const desc = String(cfg.description ?? "").trim();
                const showPrice = cfg.showPrice === undefined ? true : Boolean(cfg.showPrice);
                const showCta = cfg.showCta === undefined ? true : Boolean(cfg.showCta);

                const ids = Array.isArray(cfg.productIds) ? cfg.productIds : [];
                const products = ids.map((id: any) => produkMap.get(Number(id))).filter(Boolean) as any[];

                return (
                  <section key={section.id} className={ui.previewSection}>
                    <h2 className={ui.sectionTitle}>
                      {section.title || "Carousel Produk"}
                    </h2>

                    {desc ? <div style={{ marginBottom: 10, fontSize: 13, opacity: 0.72, maxWidth: 820 }}>{desc}</div> : null}

                    {products.length ? (
                      <div className={ui.pcRow}>
                        {products.map((p: any) => {
                          const mainId = p.mainImageId ? Number(p.mainImageId) : null;
                          const gId = pickFirstGalleryImageId(p.galleryImageIds);
                          const pickedId = mainId || gId;
                          const imgUrl = pickedId ? imageMap.get(Number(pickedId))?.url ?? null : null;

                          const href = p.slug ? `/produk/${p.slug}` : "#";
                          const pr = computeHargaSetelahPromo(p);
                          const priceNode = showPrice ? (
                            pr.isPromo ? (
                              <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                                <div style={{ display: "flex", alignItems: "baseline", gap: 8, flexWrap: "wrap" }}>
                                  <span style={{ fontWeight: 800 }}>{formatRupiah(pr.hargaFinal)}</span>
                                </div>
                                <div style={{ display: "flex", alignItems: "baseline", gap: 8, flexWrap: "wrap" }}>
                                  <span style={{ textDecoration: "line-through", opacity: 0.6 }}>
                                    {formatRupiah(pr.hargaAsli)}
                                  </span>
                                  <span style={{ fontWeight: 800 }}>{pr.promoLabel}</span>
                                </div>
                              </div>
                            ) : (
                              <>{formatRupiah(p.harga)}</>
                            )
                          ) : null;
                          const metaParts = [p.kategori, p.subkategori].filter(Boolean);

                          return (
                            <article key={Number(p.id)} className={ui.pcCard}>
                              {imgUrl ? (
                                <div className={ui.pcMedia}>
                                  <div className={ui.pcMediaBlur} style={{ backgroundImage: `url(${imgUrl})` }} />
                                  <img className={ui.pcMediaImg} src={imgUrl} alt={String(p.nama ?? "Produk")} />
                                </div>
                              ) : (
                                <div className={ui.pcMediaPlaceholder} />
                              )}

                              <div className={ui.pcBody}>
                                <div className={ui.pcTitle}>{String(p.nama ?? "Produk")}</div>

                                {showPrice ? <div className={ui.pcPrice}>{priceNode}</div> : null}
                                <div className={ui.pcMeta}>{metaParts.length ? metaParts.join(" • ") : ""}</div>

                                <div className={ui.pcCtaWrap}>
                                  {showCta ? (
                                    <a className={ui.pcCta} href={href}>
                                      Lihat Produk
                                    </a>
                                  ) : (
                                    <div className={ui.pcCtaPlaceholder} />
                                  )}
                                </div>
                              </div>
                            </article>
                          );
                        })}
                      </div>
                    ) : (
                      <div className={ui.notice}>Belum ada produk dipilih.</div>
                    )}
                  </section>
                );
              }              // HIGHLIGHT COLLECTION
              if (t === "HIGHLIGHT_COLLECTION") {
                const cfg = normalizeConfig(t, section.config) as any;

                const heroId = Number(cfg.heroImageId);
                const heroUrl = Number.isFinite(heroId) && heroId > 0 ? imageMap.get(heroId)?.url ?? null : null;

                const headline = String(cfg.headline ?? "").trim();
                const description = String(cfg.description ?? "").trim();

                const ctaText = String(cfg.ctaText ?? "").trim();
                const ctaHref = String(cfg.ctaHref ?? "").trim();

                const layout = String(cfg.layout ?? "FEATURED_LEFT");
                const sectionTheme = String(cfg.sectionTheme ?? "FOLLOW_NAVBAR").trim();
                const themeAttr = sectionTheme === "FOLLOW_NAVBAR" ? undefined : sectionTheme;

                const productIds: number[] = Array.isArray(cfg.productIds) ? cfg.productIds : [];
                const products = productIds.map((id) => produkMap.get(Number(id))).filter(Boolean) as any[];

                const hasOverlayContent = Boolean(headline || description || (ctaText && ctaHref));
                const useOverlay = Boolean(heroUrl) && hasOverlayContent;

                return (
                  <section key={section.id} className={ui.previewSection}>
                    <article
                      className={ui.hcSection}
                      data-theme={themeAttr}
                      data-layout={layout}
                      data-hc-layout={layout}
                            data-hc-nohero={!heroUrl ? "1" : undefined}
      >
                      <div className={ui.hcInner}>
                        {/* Keep header ONLY if we are not using the hero overlay */}
                        {!useOverlay ? (
                          <header className={ui.hcHeader}>
                            {headline ? <div className={ui.hcTitle}>{headline}</div> : null}
                            {description ? <div className={ui.hcDesc}>{description}</div> : null}

                            {ctaText && ctaHref ? (
                              <a className={ui.hcCta} href={ctaHref}>
                                {ctaText}
                              </a>
                            ) : null}
                          </header>
                        ) : null}

                        <div className={ui.hcGrid}>
            {heroUrl ? (
              <div className={ui.hcHero}>
                <div className={ui.hcHeroMedia}>
                                <div className={ui.hcHeroMediaBlur} style={{ backgroundImage: `url(${heroUrl})` }} />
                                <img className={ui.hcHeroMediaImg} src={heroUrl} alt={headline || "Highlight"} />

                                {useOverlay ? (
                                  <div className={ui.hcHeroOverlay}>
                                    <div className={ui.hcHeroGlass}>
                                      {headline ? <div className={ui.hcHeroOverlayTitle}>{headline}</div> : null}
                                      {description ? <div className={ui.hcHeroOverlayDesc}>{description}</div> : null}

                                      {ctaText && ctaHref ? (
                                        <a className={ui.hcHeroOverlayCta} href={ctaHref}>
                                          {ctaText}
                                        </a>
                                      ) : null}
                                    </div>
                                  </div>
                                ) : null}
                              </div>
              </div>
            ) : null}

                          <div className={ui.hcItems}>
                            {products.length ? (
                              products.map((p: any) => {
                                const mainId = p.mainImageId ? Number(p.mainImageId) : null;
                                const gId = pickFirstGalleryImageId(p.galleryImageIds);
                                const pickedId = mainId || gId;
                                const imgUrl = pickedId ? imageMap.get(Number(pickedId))?.url ?? null : null;

                                const href = p.slug ? `/produk/${p.slug}` : "#";
                                const pr = computeHargaSetelahPromo(p);
                                const priceNode = pr.isPromo ? (
                              <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                                <div style={{ display: "flex", alignItems: "baseline", gap: 8, flexWrap: "wrap" }}>
                                  <span style={{ fontWeight: 800 }}>{formatRupiah(pr.hargaFinal)}</span>
                                </div>
                                <div style={{ display: "flex", alignItems: "baseline", gap: 8, flexWrap: "wrap" }}>
                                  <span style={{ textDecoration: "line-through", opacity: 0.6 }}>
                                    {formatRupiah(pr.hargaAsli)}
                                  </span>
                                  <span style={{ fontWeight: 800 }}>{pr.promoLabel}</span>
                                </div>
                              </div>
                            ) : (
                                  <>{formatRupiah(p.harga)}</>
                                );

                                return (
                                  <a key={Number(p.id)} href={href} className={ui.hcItem}>
                                    {imgUrl ? (
                                      <div className={ui.hcItemMedia}>
                                        <div className={ui.hcItemMediaBlur} style={{ backgroundImage: `url(${imgUrl})` }} />
                                        <img className={ui.hcItemMediaImg} src={imgUrl} alt={String(p.nama ?? "Produk")} />
                                      </div>
                                    ) : (
                                      <div className={ui.hcItemEmptyMedia} />
                                    )}

                                    <div className={ui.hcItemBody}>
                                      <div className={ui.hcItemTitle}>{String(p.nama ?? "Produk")}</div>
                                      {p.harga ? <div className={ui.hcItemPrice}>{priceNode}</div> : null}
                                    </div>
                                  </a>
                                );
                              })
                            ) : (
                              <div className={ui.notice}>Belum ada produk dipilih.</div>
                            )}
                          </div>
                        </div>
                      </div>
                    </article>
                  </section>
                );
              }

              // ROOM CATEGORY (Kategori Ruangan)
              if (t === "ROOM_CATEGORY") {
                const cfg = normalizeConfig(t, section.config) as any;
                const cards = Array.isArray(cfg.cards) ? cfg.cards : [];
                const sectionTitle = section.title || "Kategori Ruangan";

                return (
                  <section key={section.id} className={ui.previewSection}>
                    <h2 className={ui.sectionTitle}>{sectionTitle}</h2>

                    {cards.length ? (
                      <div className={ui.roomGrid} aria-label="Grid Kategori Ruangan">
                        {cards.map((card: any, idx: number) => {
                          const key = String(card?.key ?? idx);

                          const title = String(card?.title ?? "").trim();
                          const badge = typeof card?.badge === "string" ? String(card.badge).trim() : "";

                          // Rule: kalau tidak ada judul -> image-only (tanpa body putih, gambar tidak crop)
                          const isImageOnly = !title;

                          const kategoriId = Number(card?.kategoriId);
                          const kategori =
                            Number.isFinite(kategoriId) && kategoriId > 0 ? kategoriMap.get(kategoriId) : null;
                          const href = kategori?.slug ? `/kategori/${kategori.slug}` : "#";

                          const imageId = Number(card?.imageId);
                          const imgUrl =
                            Number.isFinite(imageId) && imageId > 0
                              ? imageMap.get(imageId)?.url ?? null
                              : Number.isFinite(kategoriId) && kategoriId > 0
                                ? autoCoverUrlByKategori.get(kategoriId) ?? null
                                : null;

                          // Optional crop vars (only applied when NOT image-only)
                          const cropY = Number(card?.cropY);
                          const zoom = Number(card?.zoom);

                          const styleVars: any = {};
                          if (imgUrl) {
                            // background layer for image-only cards (fills arch without cropping main image)
                            styleVars["--rc-bg" as any] = `url("${imgUrl}")`;
                          }
                          if (!isImageOnly) {
                            if (Number.isFinite(cropY)) {
                              styleVars["--rc-cropY"] = `${Math.max(0, Math.min(100, cropY))}%`;
                            }
                            if (Number.isFinite(zoom)) {
                              styleVars["--rc-zoom"] = String(Math.max(1, Math.min(3, zoom)));
                            }
                          }

                          return (
                            <a key={key} href={href} className={ui.roomCardLink}>
                              <div
                                className={`${ui.roomCard} ${isImageOnly ? ui.roomCardImageOnly : ""}`}
                                style={styleVars}
                              >
                                <div className={ui.roomMedia}>
                                  {imgUrl ? (
                                    <img className={ui.roomImg} src={imgUrl} alt={title || "Kategori Ruangan"} />
                                  ) : (
                                    <div className={ui.roomMediaPlaceholder} aria-hidden="true" />
                                  )}
                                </div>

                                {!isImageOnly ? (
                                  <div className={ui.roomBody}>
                                    <div className={ui.roomTopRow}>
                                      <div className={ui.roomTitle}>{title}</div>
                                      {badge ? <span className={ui.roomBadge}>{badge}</span> : null}
                                    </div>
                                  </div>
                                ) : null}
                              </div>
                            </a>
                          );
                        })}
                      </div>
                    ) : (
                      <div className={ui.notice}>Belum ada kartu kategori ruangan.</div>
                    )}
                  </section>
                );
              }


              // fallback
              return (
                <section key={section.id} className={ui.previewSection}>
                  <h2 className={ui.sectionTitle}>
                    {section.title || "Section"}
                  </h2>
                  <pre style={{ fontSize: 12, opacity: 0.8, whiteSpace: "pre-wrap" }}>
                    {JSON.stringify(section.config ?? {}, null, 2)}
                  </pre>
                </section>
              );
            })}
          </>
        ) : (
          <div className={ui.noticeWrap}>
            <div className={ui.notice}>Belum ada section aktif untuk theme ini.</div>
          </div>
        )}
      </main>
    </>
  );
}
